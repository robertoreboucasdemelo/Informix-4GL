#-----------------------------------------------------------------------------#
# Porto Seguro Cia Seguros Gerais                                             #
#.............................................................................#
# Sistema........: Regras Siebel                                              #
# Modulo.........: bdata001                                                   #
# Objetivo.......: Batch de Geracao do Arquivo Para o Siebel                  #
# Analista Resp. : Amilton Pinto                                              #
# PSI            :                                                            #
#.............................................................................#
# Desenvolvimento: R.Fornax                                                   #
# Liberacao      : 05/09/2013                                                 #
#.............................................................................#

database porto

globals
   define g_ismqconn smallint
end globals
define m_path_origem1    char(100)
define m_path_origem2    char(100)
define m_path_origem3    char(100)
define m_path_log        char(100)
define m_path_arq_esp    char(100)
define m_path_arq_ser    char(100)
define m_path_arq_cla    char(100)
define m_bdata001_prep   smallint
define m_mensagem        char(150)
define m_seq             integer
define m_cont            integer
define m_first           integer
define m_quebra          integer
define m_acesso          integer
define m_flag            integer
define mr_count1 record
   lidos    integer,
   motor    integer,
   relat    integer,
   claus    integer,
   cober    integer,
   categ    integer,
   cidad    integer,
   apoli    integer,
   cpf      integer,
   claus2   integer,
   des_clau integer
end record
define mr_total record
   lidos    integer,
   motor    integer,
   relat    integer,
   claus    integer,
   cober    integer,
   categ    integer,
   cidad    integer,
   apoli    integer,
   cpf      integer,
   claus2   integer,
   des_clau integer
end record
define mr_param record
	  ini date                            ,
	  fim date                            ,
	  hour_ini datetime hour to second    ,
	  hour_fim datetime hour to second
end record


define mr_especialidade record
  srvespnum like datksrvesp.srvespnum ,
  srvespnom like datksrvesp.srvespnom ,
  regatldat like datksrvesp.regatldat
end record


define mr_processo1 record
  srvgrptipcod  like datksrvgrptip.srvgrptipcod ,
  srvgrptipnom  like datksrvgrptip.srvgrptipnom ,
  srvcod        like datksrv.srvcod             ,
  srvnom        like datksrv.srvnom             ,
  srvespcod     like datksrvgrpesp.srvespcod    ,
  srvespnom     like datksrvesp.srvespnom
end record


define mr_processo2 record
  succod                  like abbmdoc.succod                      ,
  aplnumdig               like abbmdoc.aplnumdig                   ,
  itmnumdig               like abbmdoc.itmnumdig                   ,
  edsnumref               like abamdoc.edsnumdig                   ,
  segnumdig               like abbmdoc.segnumdig                   ,
  clalclcod               like abbmdoc.clalclcod                   ,
  cbtcod                  like abbmcasco.cbtcod                    ,
  ctgtrfcod               like abbmcasco.ctgtrfcod                 ,
  clcdat                  like abbmcasco.clcdat                    ,
  clscod                  like abbmclaus.clscod                    ,
  empcod                  like datkplncls.empcod                   ,
  ramcod                  like datkplncls.ramcod                   ,
  plnclscod               like datkplncls.plnclscod                ,
  srvgrptipcod            like datksrvgrptip.srvgrptipcod          ,
  srvgrptipnom            like datksrvgrptip.srvgrptipnom          ,
  srvcod                  like datksrv.srvcod                      ,
  srvnom                  like datksrv.srvnom                      ,
  srvplnclsevnlimvlr      like datksrvplncls.srvplnclsevnlimvlr    ,
  srvplnclsevnlimundnom   like datksrvplncls.srvplnclsevnlimundnom ,
  srvespnum               like datksrvesp.srvespnum                ,
  srvespnom               like datksrvesp.srvespnom                ,
  clssrvesplimvlr         like datkclssrvesp.clssrvesplimvlr       ,
  clssrvesplimundnom      like datkclssrvesp.clssrvesplimundnom    ,
  undsrvcusvlr            like datkclssrvesp.undsrvcusvlr          ,
  undsrvcusundnom         like datkclssrvesp.undsrvcusundnom       ,
  empnom                  like gabkemp.empnom                      ,
  srvplnclscod            like datksrvplncls.srvplnclscod          ,
  lclclartccod            like datklclclartc.lclclartccod          ,
  endcid                  like gsakend.endcid                      ,
  endufd                  like gsakend.endufd                      ,
  emsdat                  like abamapol.emsdat                     ,
  codcls                  like datkplncls.clscod                   ,
  clsnom                  like datkplncls.clsnom                   ,
  clssitflg               like datkplncls.clssitflg                ,
  codprod                 smallint                                 ,
  nscdat                  like gsakseg.nscdat                      ,
  segsex                  like gsakseg.segsex                      ,
  pestip                  like gsakseg.pestip                      ,
  viginc                  like abamapol.viginc                     ,
  vigfnl                  like abamapol.vigfnl                     ,
  vcluso                  like abbmveic.vcluso                     ,
  rspdat                  like abbmquestionario.rspdat             ,
  rspcod                  like abbmquestionario.rspcod             ,
  perfil                  integer                                  ,
  imsvlr                  like abbmcasco.imsvlr                    ,
  prporgidv               like abbmdoc.prporgidv                   ,
  prpnumidv               like abbmdoc.prpnumidv                   ,
  cgccpfnum               like gsakseg.cgccpfnum                   ,
  cgcord                  like gsakseg.cgcord                      ,
  cgccpfdig               like gsakseg.cgccpfdig                   ,
  data_atual              char(20)                 ,
  data_canc               datetime year to minute                  ,
  documento               char(30)                                 ,
  doc_prop                char(30)
end record


define mr_funapol  record
   resultado       char(01),
   dctnumseq       decimal(04,00),
   vclsitatu       decimal(04,00),
   autsitatu       decimal(04,00),
   dmtsitatu       decimal(04,00),
   dpssitatu       decimal(04,00),
   appsitatu       decimal(04,00),
   vidsitatu       decimal(04,00)
end record

define mr_data record
  inicio date ,
  fim    date
end record

#========================================================================
main
#========================================================================

   # Funcao responsavel por preparar o programa para a execucao
   # - Prepara as instrucoes SQL
   # - Obtem os caminhos de processamento
   # - Cria o arquivo de log
   #

   initialize mr_count1.*, mr_param.* to null
   call bdata001_cria_log()

   call bdata001_exibe_inicio()

   call fun_dba_abre_banco("CT24HS")

   set lock mode to wait 10
   set isolation to dirty read

   let m_bdata001_prep = false


   let mr_total.lidos      = 0
   let mr_total.motor      = 0
   let mr_total.relat      = 0
   let mr_total.claus      = 0
   let mr_total.cober      = 0
   let mr_total.categ      = 0
   let mr_total.cidad      = 0
   let mr_total.apoli      = 0
   let mr_total.cpf        = 0
   let mr_total.claus2     = 0
   let mr_total.des_clau   = 0
   display "##################################"
   display " CRIANDO TEMPORARIA... "
   display "##################################"

   if not bdata001_cria_temporaria() then
   	  exit program
   end if

   display "##################################"
   display " PREPARANDO... "
   display "##################################"

   call bdata001_prepare()


   display "##################################"
   display " RECUPERANDO CAMINHOS... "
   display "##################################"

   call bdata001_obtem_caminhos()


   #display "##################################"
   #display " CARREGANDO TEMPORARIA... "
   #display "##################################"


   #if bdata001_carrega_temporaria() then
   #
   #	  display "##################################"
   #    display " CARREGANDO ESPECIALIDADE... "
   #    display "##################################"
   #
   #    call bdata001_carrega_especialidade()
   #
   #end if

   #drop table t_especialidade
   #display "##################################"
   #display " CARREGANDO GRUPOS E SERVICOS... "
   #display "##################################"

   #call bdata001_carrega_servico()


   if bdata001_valida_carga() then

        display "##################################"
        display " CARREGANDO APOLICES FULL... "
        display "##################################"

        if not bdata001_carga_full() then
           exit program
        end if

   else

   	    initialize mr_data.* to null

   	    call bdata001_carga_diaria()

   	    call bdata001_recupera_arquivo_diario()


   	    display "##################################"
   	    display " CARREGANDO APOLICES DIARIAS... "
   	    display "##################################"
   	    start report bdata001_report2 to m_path_arq_cla

   	    call bdata001_carrega_beneficio()
   	    finish report bdata001_report2
   	    call bdata001_exibe_dados_totais()

   end if

   call bdata001_exibe_final()
   call bdata001_dispara_email()


#========================================================================
end main
#========================================================================

#===============================================================================
 function bdata001_prepare()
#===============================================================================

define l_sql char(10000)

 let l_sql = ' select codigo            '
          ,  '      , nome              '
          ,  '   from t_especialidade   '
          ,  '  order by codigo         '
 prepare p_bdata001_001 from l_sql
 declare c_bdata001_001 cursor for p_bdata001_001

 let l_sql = ' select count(*)        '
          ,  '  from datksrvesp       '
          ,  '  where srvespnum   = ? '
 prepare p_bdata001_002 from l_sql
 declare c_bdata001_002 cursor for p_bdata001_002

 let l_sql =  ' insert into datksrvesp     '
           ,  '   (srvespnum               '
           ,  '   ,srvespnom               '
           ,  '   ,regatldat)              '
           ,  ' values(?,?,?)              '
 prepare p_bdata001_003 from l_sql


 let l_sql =  ' select a.srvgrptipcod  ,              '
             ,'        a.srvgrptipnom  ,              '
             ,'        c.srvcod        ,              '
             ,'        c.srvnom        ,              '
             ,'        d.srvespcod     ,              '
             ,'        e.srvespnom                    '
             ,' from datksrvgrptip a ,                '
             ,'      datksrvgrp b    ,                '
             ,'      datksrv c       ,                '
             ,'      datksrvgrpesp d ,                '
             ,'      datksrvesp e                     '
             ,' where a.srvgrptipcod = b.srvgrptipcod '
             ,' and b.srvcod = c.srvcod               '
             ,' and b.srvgrpcod = d.srvgrpcod         '
             ,' and d.srvespcod = e.srvespnum         '
             ,' and a.srvgrptipsitflg = "A"           '
             ,' and b.regsitflg = "A"                 '
  prepare p_bdata001_004 from l_sql
  declare c_bdata001_004 cursor for p_bdata001_004


  let l_sql =  ' select a.emsdat    ,            '
              ,'        a.viginc    ,            '
              ,'        a.vigfnl    ,            '
              ,'        b.succod    ,            '
              ,'        b.aplnumdig ,            '
              ,'        b.itmnumdig ,            '
              ,'        b.prporgidv ,            '
              ,'        b.prpnumidv              '
              ,' from abamapol a,                '
              ,'      abbmdoc  b                 '
              ,' where a.succod = b.succod       '
              ,'   and a.aplnumdig = b.aplnumdig '
              ,'   and a.emsdat = ?              '
              ,'   and b.dctnumseq = (select     '
              ,'   max(c.dctnumseq)              '
              ,'   from abbmdoc c                '
              ,'   where a.succod = c.succod     '
              ,'   and a.aplnumdig = c.aplnumdig)'
              ,' group by 1,2,3,4,5,6,7,8        '
              ,' order by 1,2,3,4,5,6,7,8        '
  prepare p_bdata001_005 from l_sql
  declare c_bdata001_005 cursor for p_bdata001_005


  let l_sql = ' select min(dctnumseq) '
             ,' from abbmdoc          '
             ,' where succod    = ?	  '
             ,'   and aplnumdig = ?	  '
             ,'   and itmnumdig = ?	  '
  prepare p_bdata001_006 from l_sql
  declare c_bdata001_006 cursor for p_bdata001_006


  let l_sql = ' select edsnumdig            '
             ,' from abamdoc                '
             ,' where abamdoc.succod    = ? '
             ,' and   abamdoc.aplnumdig = ? '
             ,' and   abamdoc.dctnumseq = ? '
  prepare p_bdata001_007 from l_sql
  declare c_bdata001_007 cursor for p_bdata001_007


  let l_sql =  ' select segnumdig,    '
              ,'        clalclcod     '
              ,' from  abbmdoc        '
              ,' where succod    =  ? '
              ,' and   aplnumdig =  ? '
              ,' and   itmnumdig =  ? '
              ,' and   dctnumseq =  ? '
  prepare p_bdata001_008 from l_sql
  declare c_bdata001_008 cursor for p_bdata001_008


  let l_sql =  ' select cbtcod    ,   '
              ,'        ctgtrfcod ,   '
              ,'        clcdat        '
              ,' from abbmcasco       '
              ,' where succod    = ?  '
              ,' and   aplnumdig = ?  '
              ,' and   itmnumdig = ?  '
              ,' and   dctnumseq = ?  '
  prepare p_bdata001_009 from l_sql
  declare c_bdata001_009 cursor for p_bdata001_009


  let l_sql =  ' select clscod       '
              ,' from abbmclaus      '
              ,' where succod    = ? '
              ,' and   aplnumdig = ? '
              ,' and   itmnumdig = ? '
              ,' and   dctnumseq = ? '
  prepare p_bdata001_010 from l_sql
  declare c_bdata001_010 cursor for p_bdata001_010


  let l_sql = ' select plnclscod          '
            , '   from datkplncls         '
            , '  where empcod =  ?        '
            , '  and   ramcod =  ?        '
            , '  and   clscod =  ?        '
            , '  and   prfcod =  ?        '
            , '  and   clsviginidat <=  ? '
            , '  and   clsvigfimdat >=  ? '
            , '  and   regsitflg = "A"    '
  prepare p_bdata001_011 from l_sql
  declare c_bdata001_011 cursor for p_bdata001_011

  let l_sql = ' select a.srvcod                 ,   '
             ,'        a.srvplnclscod           ,   '
             ,'        b.clscod                 ,   '
             ,'        b.clsnom                 ,   '
             ,'        b.clssitflg                  '
             ,' from datksrvplncls a,               '
             ,'      datkplncls b                   '
             ,' where b.plnclscod  = a.plnclscod    '
             ,' and   a.plnclscod  = ?              '
  prepare p_bdata001_012 from l_sql
  declare c_bdata001_012 cursor for p_bdata001_012

  let l_sql = ' select empnom     '
             ,' from gabkemp      '
             ,' where empcod = ? 	'
  prepare p_bdata001_013 from l_sql
  declare c_bdata001_013 cursor for p_bdata001_013


  let l_sql = ' select count(*)         '
             ,' from datkcbtcss         '
             ,' where srvclscod   =  ?  '
             ,' and   cbtcod      =  ?  '
  prepare p_bdata001_014 from l_sql
  declare c_bdata001_014 cursor for p_bdata001_014


  let l_sql = ' select count(*)        '
             ,' from datktrfctgcss     '
             ,' where srvclscod   =  ? '
             ,' and   trfctgcod   =  ? '
  prepare p_bdata001_015 from l_sql
  declare c_bdata001_015 cursor for p_bdata001_015


  let l_sql = ' select lclclartccod       '
             ,' from datklclclartc        '
             ,' where srvclscod    =  ?   '
             ,' and   lclclacod    =  ?   '
  prepare p_bdata001_016 from l_sql
  declare c_bdata001_016 cursor for p_bdata001_016


  let l_sql = ' select count(*)              '
             ,' from datkrtcece a ,          '
             ,'      glakcid    b   	       '
             ,' where a.cidcod = b.cidcod    '
             ,' and   a.lclclartccod =  ?    '
             ,' and   b.cidnom   	   =  ?    '
             ,' and   b.ufdcod       =  ?    '
  prepare p_bdata001_017 from l_sql
  declare c_bdata001_017 cursor for p_bdata001_017



  let l_sql = ' select endcid ,      '
             ,'        endufd        '
             ,' from gsakend         '
             ,' where segnumdig =  ? '
             ,' and   endfld    =  1 '
  prepare p_bdata001_018 from l_sql
  declare c_bdata001_018 cursor for p_bdata001_018


  let l_sql =  ' update datkplncls     '
            ,  ' set irdclsflg = "S"   '
            ,  ' where plnclscod = ?   '
  prepare p_bdata001_019 from l_sql

  let l_sql = ' select cpodes        '
             ,' from datkdominio     '
             ,' where cponom =  ?    '
             ,' and   cpocod =  ?    '
  prepare p_bdata001_020 from l_sql
  declare c_bdata001_020 cursor for p_bdata001_020


  let l_sql =  ' update datkdominio    '
             , ' set   cpodes =  ?     '
             , ' where cponom =  ?     '
             , ' and   cpocod =  ?     '
  prepare p_bdata001_021 from l_sql


  let l_sql = 'select nscdat,        ',
              '       segsex,        ',
              '       pestip,        ',
              '       cgccpfnum,     ',
              '       cgcord   ,     ',
              '       cgccpfdig      ',
              ' from gsakseg         ',
              ' where segnumdig  = ? '
  prepare p_bdata001_022 from l_sql
  declare c_bdata001_022 cursor for p_bdata001_022

  let l_sql = ' select vcluso      '
   				   ,' from abbmveic      '
             ,' where succod   = ? '
     				 ,' and  aplnumdig = ? '
     				 ,' and  itmnumdig = ? '
      	  	 ,' and  dctnumseq = ? '
  prepare p_bdata001_023 from l_sql
  declare c_bdata001_023 cursor for p_bdata001_023
  let l_sql = 'select imsvlr        '
   				   ,' from abbmcasco      '
             ,' where succod    = ? '
     				 ,'   and aplnumdig = ? '
     				 ,'   and itmnumdig = ? '
      	  	 ,'   and dctnumseq = ? '
  prepare p_bdata001_024 from l_sql
  declare c_bdata001_024 cursor for p_bdata001_024
  let l_sql = 'select rspdat           '
   				   ,' from abbmquestionario  '
             ,' where succod    = ?    '
     				 ,'   and aplnumdig = ?    '
     				 ,'   and itmnumdig = ?    '
      	  	 ,'   and dctnumseq = ?    '
      	  	 ,'   and qstcod    = 2    '
  prepare p_bdata001_025 from l_sql
  declare c_bdata001_025 cursor for p_bdata001_025
  let l_sql = 'select rspcod           '
   				   ,' from abbmquestionario  '
             ,' where succod    = ?    '
     				 ,'   and aplnumdig = ?    '
     				 ,'   and itmnumdig = ?    '
      	  	 ,'   and dctnumseq = ?    '
      	  	 ,'   and qstcod    = 120  '
  prepare p_bdata001_026 from l_sql
  declare c_bdata001_026 cursor for p_bdata001_026
  let l_sql = ' select cpodes        '
             ,' from datkdominio     '
             ,' where cponom =  ?    '
  prepare p_bdata001_027 from l_sql
  declare c_bdata001_027 cursor for p_bdata001_027
  let m_bdata001_prep = true

#========================================================================
end function
#========================================================================


#========================================================================
 function bdata001_carrega_temporaria()
#========================================================================

     whenever error continue

    load from m_path_arq_esp delimiter ';' insert into t_especialidade

    whenever error stop

    if sqlca.sqlcode <> 0 then
      let m_mensagem = '(ERRO ' , sqlca.sqlcode ,') - ERRO NA ABERTURA DO ARQUIVO DE IMPORTACAO!'
      call ERRORLOG(m_mensagem);
      return false
    end if


     return true

#========================================================================
end function
#========================================================================

#========================================================================
 function bdata001_carrega_especialidade()
#========================================================================

initialize mr_especialidade.* to null

   #--------------------------------------------------------
    # Recupera os Dados da Temporaria
   #--------------------------------------------------------

   open c_bdata001_001
    foreach c_bdata001_001 into mr_especialidade.srvespnum
   	                        , mr_especialidade.srvespnom

         let mr_especialidade.regatldat = today

         if bdata001_valida_especialidade() then
           call bdata001_inclui_especialidade()
         end if

     end foreach


#========================================================================
end function
#========================================================================

#========================================================================
 function bdata001_valida_especialidade()
#========================================================================

define l_cont integer

let l_cont = 0


     #--------------------------------------------------------
    # Valida Se a Especialidade Ja Foi Cadastrada
    #--------------------------------------------------------

    open c_bdata001_002 using mr_especialidade.srvespnum

    whenever error continue
    fetch c_bdata001_002 into l_cont
    whenever error stop

    if l_cont >  0  then
       return false
    end if


     return true

#========================================================================
end function
#========================================================================

#========================================================================
 function bdata001_inclui_especialidade()
#========================================================================

  whenever error continue
   execute p_bdata001_003 using mr_especialidade.srvespnum
                              , mr_especialidade.srvespnom
                              , mr_especialidade.regatldat


   whenever error continue

   if sqlca.sqlcode <> 0 then
      let m_mensagem = 'ERRO(',sqlca.sqlcode,') NA INCLUSAO DA ESPECIALIDADE! ', mr_especialidade.srvespnum
      call ERRORLOG(m_mensagem);
      display m_mensagem
   end if


#========================================================================
end function
#========================================================================






#========================================================================
function bdata001_cria_log()
#========================================================================

   define l_path char(200)

   let l_path = null
   let l_path = f_path("DAT","LOG")

   if l_path is null or
      l_path = " " then
      let l_path = "."
   end if

   let l_path = m_path_log clipped, "bdata001.log"

   call startlog(l_path)

#========================================================================
end function
#========================================================================

#========================================================================
function bdata001_obtem_caminhos()
#========================================================================

define lr_param record
	dia  integer,
  mes  integer,
  ano  integer,
  data char(08)
end record

initialize lr_param.* to null

   let lr_param.dia = day(today)
   let lr_param.mes = month(today)
   let lr_param.ano = year(today)


   let m_path_origem1    = " "
   let m_path_origem2    = " "
   let m_path_origem3    = " "
   let m_path_log        = " "

   let lr_param.data = lr_param.dia using "&&", lr_param.mes using "&&", lr_param.ano using "&&&&"

   call bdata001_recupera_dir_esp()
   let m_path_arq_esp  = m_path_origem1 clipped, "/especialidade.txt"
   call bdata001_recupera_dir_ser()
   let m_path_arq_ser  = m_path_origem2 clipped, "/servicos_", lr_param.data, ".txt"


#========================================================================
end function
#========================================================================

#========================================================================
function bdata001_recupera_arquivo_diario()
#========================================================================

define lr_param record
	dia  integer,
  mes  integer,
  ano  integer,
  data char(08)
end record

initialize lr_param.* to null

   let lr_param.dia = day(mr_data.inicio)
   let lr_param.mes = month(mr_data.inicio)
   let lr_param.ano = year(mr_data.inicio)

   let lr_param.data = lr_param.dia using "&&", lr_param.mes using "&&", lr_param.ano using "&&&&"

   call bdata001_recupera_dir_ben()
   let m_path_arq_cla  = m_path_origem3 clipped, "/beneficios_", lr_param.data, ".txt"


#========================================================================
end function
#========================================================================


#========================================================================
 function bdata001_cria_temporaria()
#========================================================================

   create temp table t_especialidade(codigo integer  ,
                                     nome  char(60)  ,
                                     grupo  integer  ,
                                     descricao char(60))

  if sqlca.sqlcode <> 0 then
      let m_mensagem = '(ERRO ' , sqlca.sqlcode ,') - ERRO NA CRIACAO DA TABELA TEMPORARIA!'
      call ERRORLOG(m_mensagem);
      display m_mensagem
      return false
  end if

  return true

#========================================================================
end function
#========================================================================

#========================================================================
 function bdata001_carrega_servico()
#========================================================================

initialize mr_processo1.* to null


    start report bdata001_report1 to m_path_arq_ser

    #--------------------------------------------------------
    # Recupera os Dados do Grupo X Servico X Especialidade
    #--------------------------------------------------------

    open c_bdata001_004
    foreach c_bdata001_004 into mr_processo1.srvgrptipcod
  	                          , mr_processo1.srvgrptipnom
                              , mr_processo1.srvcod
                              , mr_processo1.srvnom
                              , mr_processo1.srvespcod
                              , mr_processo1.srvespnom
         output to report bdata001_report1()

    end foreach

    finish report bdata001_report1

#========================================================================
end function
#========================================================================

#========================================================================
 report bdata001_report1()
#========================================================================

 output
  report to printer
  page      length  66
  left      margin  00
  top       margin  00
  bottom    margin  00

   format

   on every row


        print column 001, mr_processo1.srvgrptipcod using "&&&&&"     , "|"
                        , mr_processo1.srvgrptipnom clipped           , "|"
                        , mr_processo1.srvcod       using "&&&&&"     , "|"
                        , mr_processo1.srvnom       clipped           , "|"

                        , mr_processo1.srvespcod    using "&&&&&"     , "|"

                        , mr_processo1.srvespnom    clipped           , "|"


#========================================================================
end report
#========================================================================

#========================================================================
 function bdata001_carrega_beneficio()
#========================================================================

define lr_retorno record
	 cont          integer  ,
	 grava         smallint ,
	 aplnumdig_ant like abbmdoc.aplnumdig
end record

define l_data date
define l_hora datetime hour to second
initialize mr_processo2.* to null

let l_data = null
let l_hora = null
let mr_processo2.empcod       = 1
let mr_processo2.ramcod       = 531
let mr_processo2.codprod      = 01
let lr_retorno.cont           = 0
let lr_retorno.grava          = false
let lr_retorno.aplnumdig_ant  = 0
let mr_count1.lidos           = 0
let mr_count1.motor           = 0
let mr_count1.relat           = 0
let mr_count1.claus           = 0
let mr_count1.cober           = 0
let mr_count1.categ           = 0
let mr_count1.cidad           = 0
let mr_count1.apoli           = 0
let mr_count1.cpf             = 0
let mr_count1.claus2          = 0
let mr_count1.des_clau        = 0

     begin work;


     #display "Query 1"
    #--------------------------------------------------------
    # Recupera o Nome da Empresa
    #--------------------------------------------------------

     open c_bdata001_013 using mr_processo2.empcod

     whenever error continue
     fetch c_bdata001_013 into mr_processo2.empnom
     whenever error stop

    #display "Query 2"
    #--------------------------------------------------------
    # Recupera os Dados da Apolice
    #--------------------------------------------------------

    open c_bdata001_005 using mr_data.inicio

    foreach c_bdata001_005 into mr_processo2.emsdat
    	                        , mr_processo2.viginc
    	                        , mr_processo2.vigfnl
    	                        , mr_processo2.succod
  	                          , mr_processo2.aplnumdig
                              , mr_processo2.itmnumdig
                              , mr_processo2.prporgidv
                              , mr_processo2.prpnumidv

       let mr_count1.apoli = mr_count1.apoli + 1
       let mr_total.apoli  = mr_total.apoli + 1

       #-------------------------------------------------------
       # Recupera a Ultima Situacao da Apolice
       #-------------------------------------------------------
        #display "Query 3"
        call f_funapol_ultima_situacao(mr_processo2.succod    ,
                                       mr_processo2.aplnumdig ,
                                       mr_processo2.itmnumdig )
        returning mr_funapol.*


        if mr_funapol.dctnumseq is null  then

            #--------------------------------------------------------
            # Recupera a Ultima Sequencia da Apolice
            #--------------------------------------------------------
            #display "Query 4"
            open c_bdata001_006 using mr_processo2.succod    ,
                                      mr_processo2.aplnumdig ,
                                      mr_processo2.itmnumdig

            whenever error continue
            fetch c_bdata001_006 into mr_funapol.dctnumseq
            whenever error stop


        end if

        #display "Query 5"
        #------------------------------------------------------
        # Recupera o Numero do Endosso
        #------------------------------------------------------

        open c_bdata001_007 using mr_processo2.succod    ,
                                  mr_processo2.aplnumdig ,
                                  mr_funapol.dctnumseq

        whenever error continue
        fetch c_bdata001_007 into mr_processo2.edsnumref
        whenever error stop

        if sqlca.sqlcode = notfound  then
           let mr_processo2.edsnumref = 0
        end if

        #display "Query 6"
        #------------------------------------------------------
        # Recupera Numero do Segurado e Classe de Localizacao
        #------------------------------------------------------


        open c_bdata001_008 using mr_processo2.succod    ,
                                  mr_processo2.aplnumdig ,
                                  mr_processo2.itmnumdig ,
                                  mr_funapol.dctnumseq
        whenever error continue
        fetch c_bdata001_008 into mr_processo2.segnumdig ,
                                  mr_processo2.clalclcod
        whenever error stop
        #display "Query 7"
        #------------------------------------------------------
        # Recupera Cidade do Segurado
        #------------------------------------------------------

        open c_bdata001_018 using mr_processo2.segnumdig

        whenever error continue
        fetch c_bdata001_018 into mr_processo2.endcid ,
                                  mr_processo2.endufd
        whenever error stop
        #display "Query 8"
        #------------------------------------------------------
        # Recupera Cobertura, Categoria e Data de Calculo
        #------------------------------------------------------

        open c_bdata001_009 using mr_processo2.succod    ,
                                  mr_processo2.aplnumdig ,
                                  mr_processo2.itmnumdig ,
                                  mr_funapol.dctnumseq
        whenever error continue
        fetch c_bdata001_009 into mr_processo2.cbtcod    ,
                                  mr_processo2.ctgtrfcod ,
                                  mr_processo2.clcdat
        whenever error stop
        #display "Query 9"
        #-----------------------------------------------------------
        # Recupera os Dados do Segurado
        #-----------------------------------------------------------
        open c_bdata001_022 using mr_processo2.segnumdig

        whenever error continue
        fetch c_bdata001_022 into mr_processo2.nscdat     ,
                                  mr_processo2.segsex     ,
                                  mr_processo2.pestip     ,
                                  mr_processo2.cgccpfnum  ,
                                  mr_processo2.cgcord     ,
                                  mr_processo2.cgccpfdig
        whenever error stop
        close c_bdata001_022
        if mr_processo2.cgccpfnum is null then
           let mr_count1.cpf = mr_count1.cpf + 1
           let mr_total.cpf  = mr_total.cpf + 1
           continue foreach
        end if
        #display "Query 10"
        #-----------------------------------------------------------
        # Recupera Se o Veiculo e 0KM
        #-----------------------------------------------------------
        open c_bdata001_023  using mr_processo2.succod    ,
                                   mr_processo2.aplnumdig ,
                                   mr_processo2.itmnumdig ,
                                   mr_funapol.dctnumseq
        whenever error continue
        fetch c_bdata001_023 into mr_processo2.vcluso
        whenever error stop
        close c_bdata001_023
        #display "Query 11"
        #-----------------------------------------------------------
        # Recupera a Importancia Segurada
        #-----------------------------------------------------------
        open c_bdata001_024  using mr_processo2.succod    ,
                                   mr_processo2.aplnumdig ,
                                   mr_processo2.itmnumdig ,
                                   mr_funapol.autsitatu
        whenever error continue
        fetch c_bdata001_024 into mr_processo2.imsvlr
        whenever error stop
        close c_bdata001_024
        if mr_processo2.pestip = "J" and
           mr_processo2.vcluso = 1   then
            #display "Query 12"
            #-----------------------------------------------------------
            # Recupera a Data de Nascimento do Principal Condutor
            #-----------------------------------------------------------
            open c_bdata001_025 using mr_processo2.succod    ,
                                      mr_processo2.aplnumdig ,
                                      mr_processo2.itmnumdig ,
                                      mr_funapol.dctnumseq
            whenever error continue
            fetch c_bdata001_025 into mr_processo2.rspdat
            whenever error stop
            close c_bdata001_025
            #display "Query 13"
            #-----------------------------------------------------------
            # Recupera o Sexo do Principal Condutor
            #-----------------------------------------------------------
            open c_bdata001_026  using mr_processo2.succod    ,
                                       mr_processo2.aplnumdig ,
                                       mr_processo2.itmnumdig ,
                                       mr_funapol.dctnumseq
            whenever error continue
            fetch c_bdata001_026  into mr_processo2.rspcod
            whenever error stop
            close c_bdata001_026
       end if
        #display "Query 14"
        #--------------------------------------------------------
        # Recupera os Dados da Clausula
        #--------------------------------------------------------

        open c_bdata001_010 using mr_processo2.succod    ,
                                  mr_processo2.aplnumdig ,
                                  mr_processo2.itmnumdig ,
                                  mr_funapol.dctnumseq
        foreach c_bdata001_010 into mr_processo2.clscod

        	   let mr_count1.lidos = mr_count1.lidos + 1
        	   let mr_total.lidos  = mr_total.lidos + 1
        	   if mr_processo2.aplnumdig <> lr_retorno.aplnumdig_ant then
        	   	  let mr_count1.claus2 = mr_count1.claus2 + 1
        	      let mr_total.claus2  = mr_total.claus2 + 1
        	   end if
        	   let lr_retorno.aplnumdig_ant = mr_processo2.aplnumdig
        	   #--------------------------------------------------------
        	   # Verifica Clausula Duplicada
        	   #--------------------------------------------------------
        	   if mr_processo2.clscod = "034" or
        	      mr_processo2.clscod = "071" or
        	      mr_processo2.clscod = "077" then
        	      	if cta13m00_verifica_clausula(mr_processo2.succod     ,
                                                mr_processo2.aplnumdig  ,
                                                mr_processo2.itmnumdig  ,
                                                mr_funapol.dctnumseq    ,
                                                mr_processo2.clscod     ) then
     								 continue foreach
  							  end if
        	   end if
        	   #--------------------------------------------------------
        	   # Recupera Perfil
        	   #--------------------------------------------------------
        	   #display "Query 15"
        	   call bdata001_calcula_perfil(mr_processo2.nscdat ,
                                          mr_processo2.segsex ,
                                          mr_processo2.pestip ,
                                          mr_processo2.viginc ,
                                          mr_processo2.vcluso ,
                                          mr_processo2.rspdat ,
                                          mr_processo2.rspcod ,
                                          mr_processo2.clscod)
             returning mr_processo2.perfil
             #display "Query 16"
             #--------------------------------------------------------
             # Regra 1 - Verifica se a Clausula Existe no Motor
             #--------------------------------------------------------

             open c_bdata001_011 using   mr_processo2.empcod ,
                                         mr_processo2.ramcod ,
                                         mr_processo2.clscod ,
                                         mr_processo2.perfil ,
                                         mr_processo2.clcdat ,
                                         mr_processo2.clcdat
             whenever error continue
             fetch c_bdata001_011 into   mr_processo2.plnclscod
             whenever error stop

             if sqlca.sqlcode = notfound  then
                if   mr_processo2.clscod = '033' or
                     mr_processo2.clscod = '034' or
                     mr_processo2.clscod = '035' or
                     mr_processo2.clscod = '044' or
                     mr_processo2.clscod = '046' or
                     mr_processo2.clscod = '047' or
                     mr_processo2.clscod = '048' or
                     mr_processo2.clscod = '34R' or
                     mr_processo2.clscod = '33R' or
                     mr_processo2.clscod = '35R' or
                     mr_processo2.clscod = '44R' or
                     mr_processo2.clscod = '46R' or
                     mr_processo2.clscod = '48R' then
                     display "Empresa.......: ", mr_processo2.empcod
                     display "Ramo..........: ", mr_processo2.ramcod
                     display "Clausula......: ", mr_processo2.clscod
                     display "Perfil........: ", mr_processo2.perfil
                     display "Data Clausula.: ", mr_processo2.clcdat
               end if
                  let mr_count1.claus = mr_count1.claus + 1
                  let mr_total.claus  = mr_total.claus + 1
                  continue foreach
             end if

             #display "Query 17"
             #--------------------------------------------------------
             # Recupera os Dados do Motor de Regras
             #--------------------------------------------------------

             open c_bdata001_012 using mr_processo2.plnclscod

             foreach c_bdata001_012 into mr_processo2.srvcod                 ,
                                         mr_processo2.srvplnclscod           ,
                                         mr_processo2.codcls                 ,
                                         mr_processo2.clsnom                 ,
                                         mr_processo2.clssitflg

                   let mr_count1.motor = mr_count1.motor + 1
                   let mr_total.motor  = mr_total.motor + 1
                   #------------------------------------------------------
                   # Regra 2 - Verifica Se Tem Cobertura
                   #------------------------------------------------------

                   #display "Query 18"
                   open c_bdata001_014 using mr_processo2.srvplnclscod ,
                                             mr_processo2.cbtcod

                   whenever error continue
                   fetch c_bdata001_014 into lr_retorno.cont
                   whenever error stop

                   if lr_retorno.cont = 0 then
                      let mr_count1.cober = mr_count1.cober + 1
                      let mr_total.cober  = mr_total.cober + 1
                      continue foreach
                   end if


                   #display "Query 19"
                   #------------------------------------------------------
                   # Regra 3 - Verifica Se Tem Categoria
                   #------------------------------------------------------

                   open c_bdata001_015 using mr_processo2.srvplnclscod ,
                                             mr_processo2.ctgtrfcod

                   whenever error continue
                   fetch c_bdata001_015 into lr_retorno.cont
                   whenever error stop

                   if lr_retorno.cont = 0 then
                      let mr_count1.categ = mr_count1.categ + 1
                      let mr_total.categ  = mr_total.categ + 1
                      continue foreach
                   end if

                   #display "Query 20"
                   #------------------------------------------------------
                   # Regra 4 - Verifica Se Tem Restricao por Classe
                   #------------------------------------------------------

                   open c_bdata001_016 using mr_processo2.srvplnclscod ,
                                             mr_processo2.clalclcod

                   whenever error continue
                   fetch c_bdata001_016 into mr_processo2.lclclartccod
                   whenever error stop

                   if sqlca.sqlcode <> notfound then

                        #display "Query 21"
                        #------------------------------------------------------
                        # Regra 5 - Verifica Se a Cidade tem Permissao
                        #------------------------------------------------------

                        open c_bdata001_017 using mr_processo2.lclclartccod ,
                                                  mr_processo2.endcid       ,
                                                  mr_processo2.endufd

                        whenever error continue
                        fetch c_bdata001_017 into lr_retorno.cont
                        whenever error stop

                        if lr_retorno.cont = 0 then
                           let mr_count1.cidad = mr_count1.cidad + 1
                           let mr_total.cidad  = mr_total.cidad + 1
                           continue foreach
                        end if
                   end if
                   let l_data = today
                   let l_hora = current
                   let mr_processo2.data_atual = l_data , " " , l_hora

                   if bdata001_valida_carga() and
                   	  m_acesso = true         then
                        if m_first  then
                           start report bdata001_report2 to m_path_arq_cla
                           let m_first = false
                        end if
                        if m_cont <= m_quebra then
                            output to report bdata001_report2()
                            let mr_count1.relat = mr_count1.relat + 1
                            let mr_total.relat  = mr_total.relat + 1
                            let m_cont = m_cont + 1
                            let lr_retorno.grava = true
                        else
                        	  let m_seq = m_seq + 1
                        	  finish report bdata001_report2
                        	  call bdata001_recupera_arquivo_full()
                            start report bdata001_report2 to m_path_arq_cla
                            output to report bdata001_report2()
                            let mr_count1.relat = mr_count1.relat + 1
                            let mr_total.relat  = mr_total.relat + 1
                            let m_cont = 2
                        end if
                   else

                   	   output to report bdata001_report2()
                   	   let mr_count1.relat = mr_count1.relat + 1
                   	   let mr_total.relat  = mr_total.relat + 1
                   	   let lr_retorno.grava = true
                   end if
             end foreach

             if lr_retorno.grava then
             	  #display "Query 22"
             	  call bdata001_atualiza_exportado()
             	  let lr_retorno.grava = false
             end if

        end foreach


    end foreach

    call bdata001_exibe_dados_parciais()

    commit work;

#========================================================================
end function
#========================================================================

#========================================================================
 report bdata001_report2()
#========================================================================

 output
  report to printer
  page      length  66
  left      margin  00
  top       margin  00
  bottom    margin  00

   format

   on every row

        print column 001   ,mr_processo2.empcod                  using "&&"                   , ";"
                            ,mr_processo2.codprod                 using "&&"                   , ";"
                            ,mr_processo2.succod                  using "<<<&"                 , "-"
                            ,mr_processo2.ramcod                  using "<<&&&"                , "-"
                            ,mr_processo2.aplnumdig               using "<<&&&&&&&"            , ";"
                            ,mr_processo2.prporgidv               using "&&"                   , "-"
                            ,mr_processo2.prpnumidv               using "<<&&&&&&&"            , ";"
                            ,mr_processo2.itmnumdig               using "<<<&&"                , ";"
                            ,mr_processo2.pestip                                               , ";"
                            ,mr_processo2.cgccpfnum               using "&&&&&&&&&"            , ";"
                            ,mr_processo2.cgcord                  using "&&&&"                 , ";"
                            ,mr_processo2.cgccpfdig               using "&&"                   , ";"
                            ,mr_processo2.srvcod                  using "&&&&&"                , ";"
                            ,mr_processo2.viginc                                               , ";"
                            ,mr_processo2.vigfnl                                               , ";"
                            ,mr_processo2.data_atual                                           , ";"
                            ,mr_processo2.data_canc                                            , ";"
                            ,mr_processo2.codcls                  clipped                      , ";"
                            ,mr_processo2.edsnumref               using "&&&&&&&&&&"           , ";"



#========================================================================
end report
#========================================================================

#========================================================================
function bdata001_exibe_inicio()
#========================================================================
define l_data  date,
       l_hora  datetime hour to second

let l_data            = today
let l_hora            = current
let mr_param.ini      = today
let mr_param.hour_ini = current
   display " "
   display "-----------------------------------------------------------"
   display " INICIO bdata001 - CARGA DE APOLICES PARA O SIEBEL         "
   display "-----------------------------------------------------------"
   display " "
   display " INICIO DO PROCESSAMENTO....: ", l_data, " ", l_hora
   call errorlog("------------------------------------------------------")
   let m_mensagem = "INICIO DO PROCESSAMENTO....: ", l_data, " ", l_hora
   call errorlog(m_mensagem)


#========================================================================
end function
#========================================================================

#========================================================================
function bdata001_exibe_final()
#========================================================================
   define l_data  date,
          l_hora  datetime hour to second


   let l_data            = today
   let l_hora            = current
   let mr_param.fim      = today
   let mr_param.hour_fim = current
   display " "
   display " TERMINO DO PROCESSAMENTO...: ", l_data, " ", l_hora
   let m_mensagem = " TERMINO DO PROCESSAMENTO...: ", l_data, " ", l_hora
   call errorlog(m_mensagem)
   call errorlog("------------------------------------------------------")

#========================================================================
end function
#========================================================================

#========================================================================
 function bdata001_atualiza_exportado()
#========================================================================

   whenever error continue
   execute p_bdata001_019 using mr_processo2.plnclscod

   whenever error continue

   if sqlca.sqlcode <> 0 then
      let m_mensagem = 'ERRO(',sqlca.sqlcode,') NA ATUALIZACAO DA FLAG EXPORTADO! ', mr_especialidade.srvespnum
      call ERRORLOG(m_mensagem);
      display m_mensagem
   end if


#========================================================================
end function
#========================================================================

#========================================================================
 function bdata001_valida_carga()
#========================================================================

define lr_retorno record
	cponom  like datkdominio.cponom,
	cpocod  like datkdominio.cpocod,
	cpodes  like datkdominio.cpodes
end record

initialize lr_retorno.* to null

let lr_retorno.cponom = "bdata001_full"
let lr_retorno.cpocod = 1


  open c_bdata001_020 using  lr_retorno.cponom ,
                             lr_retorno.cpocod
  whenever error continue
  fetch c_bdata001_020 into lr_retorno.cpodes
  whenever error stop

  if lr_retorno.cpodes =  "S"  then
     return true
  end if


  return false


#========================================================================
end function
#========================================================================

#========================================================================
 function bdata001_carga_diaria()
#========================================================================

  let mr_data.inicio = today - 1

  display ""
  display "======================================="
  display "PROCESSANDO DATA...", mr_data.inicio
  display "======================================="
#========================================================================
end function
#========================================================================

#========================================================================
function bdata001_recupera_arquivo_full()
#========================================================================

define lr_param record
  mes  integer ,
  ano  integer ,
  data char(06)
end record

initialize lr_param.* to null


   let lr_param.mes = month(mr_data.inicio)
   let lr_param.ano = year(mr_data.inicio)

   let lr_param.data = lr_param.mes using "&&", lr_param.ano using "&&&&"

   let m_path_arq_cla  = "beneficios_", lr_param.data, m_seq using "_&&&&&", ".txt"


#========================================================================
end function
#========================================================================

#========================================================================
 function bdata001_recupera_data_inicio()
#========================================================================

define lr_retorno record
	cponom  like datkdominio.cponom,
	cpocod  like datkdominio.cpocod,
	cpodes  like datkdominio.cpodes
end record

initialize lr_retorno.* to null

let lr_retorno.cponom = "bdata001_inicio"
let lr_retorno.cpocod = 1


  open c_bdata001_020 using  lr_retorno.cponom ,
                             lr_retorno.cpocod
  whenever error continue
  fetch c_bdata001_020 into lr_retorno.cpodes
  whenever error stop

  if lr_retorno.cpodes is not null  then
     let mr_data.inicio =  lr_retorno.cpodes
  end if


#========================================================================
end function
#========================================================================

#========================================================================
 function bdata001_recupera_data_fim()
#========================================================================

define lr_retorno record
	cponom  like datkdominio.cponom,
	cpocod  like datkdominio.cpocod,
	cpodes  like datkdominio.cpodes
end record

initialize lr_retorno.* to null

let lr_retorno.cponom = "bdata001_fim"
let lr_retorno.cpocod = 1


  open c_bdata001_020 using  lr_retorno.cponom ,
                             lr_retorno.cpocod
  whenever error continue
  fetch c_bdata001_020 into lr_retorno.cpodes
  whenever error stop

  if lr_retorno.cpodes is not null  then
     let mr_data.fim =  lr_retorno.cpodes
  end if


#========================================================================
end function
#========================================================================

#========================================================================
 function bdata001_carga_full()
#========================================================================

define lr_retorno record
   mesant smallint,
   mesatu smallint
end record

initialize lr_retorno.* , mr_data.* to null

let lr_retorno.mesant = 13

  call bdata001_recupera_data_inicio()

  call bdata001_recupera_data_fim()

  if mr_data.inicio is null or
  	 mr_data.fim    is null then
  	  let m_mensagem = "Datas Invalidas!"
  	  call ERRORLOG(m_mensagem);
  	  display m_mensagem
  	  return false
  end if

  if mr_data.fim	< mr_data.inicio then
  	  let m_mensagem = "Data Final Maior Que a Inicial"
      call ERRORLOG(m_mensagem);
      display m_mensagem
      return false
  end if

  let  m_seq   = 1
  let  m_cont  = 1
  let  m_first = true
  let  m_flag  = false

  call bdata001_recupera_quebra()
  returning m_acesso

  while mr_data.inicio <=  mr_data.fim

  	   let lr_retorno.mesatu = month(mr_data.inicio)
  	   display ""
  	   display "======================================="
  	   display "PROCESSANDO DATA...", mr_data.inicio
  	   display "======================================="
  	   if lr_retorno.mesatu <> lr_retorno.mesant then
  	   	    let  m_seq  = 1
  	   	    let  m_cont = 1
  	        call bdata001_recupera_arquivo_full()
  	        call bdata001_atualiza_data()
  	        if m_flag then
  	           finish report bdata001_report2
  	        end if

  	        start report bdata001_report2 to m_path_arq_cla
  	        let m_flag = true
  	        let lr_retorno.mesant = lr_retorno.mesatu
  	   end if

  	   call bdata001_carrega_beneficio()

       let mr_data.inicio = mr_data.inicio + 1 units day


  end while
  finish report bdata001_report2
  call bdata001_exibe_dados_totais()
  call bdata001_atualiza_data()
  return true
#========================================================================
end function
#========================================================================

#========================================================================
 function bdata001_atualiza_data()
#========================================================================

define lr_retorno record
	cponom  like datkdominio.cponom,
	cpocod  like datkdominio.cpocod,
	cpodes  like datkdominio.cpodes
end record

initialize lr_retorno.* to null

let lr_retorno.cponom = "bdata001_inicio"
let lr_retorno.cpocod = 1
let lr_retorno.cpodes = mr_data.inicio

   whenever error continue
   execute p_bdata001_021 using lr_retorno.cpodes,
                                lr_retorno.cponom,
                                lr_retorno.cpocod
   whenever error continue

   if sqlca.sqlcode <> 0 then
      let m_mensagem = 'ERRO(',sqlca.sqlcode,') NA ATUALIZACAO DA DATA! '
      call ERRORLOG(m_mensagem);
      display m_mensagem
   end if


#========================================================================
end function
#========================================================================
#========================================================================
 function bdata001_recupera_dir_esp()
#========================================================================
define lr_retorno record
	cponom  like datkdominio.cponom,
	cpocod  like datkdominio.cpocod,
	cpodes  like datkdominio.cpodes
end record
initialize lr_retorno.* to null
let lr_retorno.cponom = "bdata001_dir_esp"
let lr_retorno.cpocod = 1
  open c_bdata001_020 using  lr_retorno.cponom ,
                             lr_retorno.cpocod
  whenever error continue
  fetch c_bdata001_020 into lr_retorno.cpodes
  whenever error stop
  if lr_retorno.cpodes is not null  then
     let m_path_origem1 = lr_retorno.cpodes
  else
  	 let m_path_origem1 = "."
  end if
#========================================================================
end function
#========================================================================
#========================================================================
 function bdata001_recupera_dir_ser()
#========================================================================
define lr_retorno record
	cponom  like datkdominio.cponom,
	cpocod  like datkdominio.cpocod,
	cpodes  like datkdominio.cpodes
end record
initialize lr_retorno.* to null
let lr_retorno.cponom = "bdata001_dir_ser"
let lr_retorno.cpocod = 1
  open c_bdata001_020 using  lr_retorno.cponom ,
                             lr_retorno.cpocod
  whenever error continue
  fetch c_bdata001_020 into lr_retorno.cpodes
  whenever error stop
  if lr_retorno.cpodes is not null  then
     let m_path_origem2 = lr_retorno.cpodes
  else
  	 let m_path_origem2 = "."
  end if
#========================================================================
end function
#========================================================================
#========================================================================
 function bdata001_recupera_dir_ben()
#========================================================================
define lr_retorno record
	cponom  like datkdominio.cponom,
	cpocod  like datkdominio.cpocod,
	cpodes  like datkdominio.cpodes
end record
initialize lr_retorno.* to null
let lr_retorno.cponom = "bdata001_dir_ben"
let lr_retorno.cpocod = 1
  open c_bdata001_020 using  lr_retorno.cponom ,
                             lr_retorno.cpocod
  whenever error continue
  fetch c_bdata001_020 into lr_retorno.cpodes
  whenever error stop
  if lr_retorno.cpodes is not null  then
     let m_path_origem3 = lr_retorno.cpodes
  else
  	 let m_path_origem3 = "."
  end if
#========================================================================
end function
#========================================================================
#----------------------------------------------#
 function bdata001_calcula_perfil(lr_param)
#----------------------------------------------#
define lr_param record
  nscdat  like gsakseg.nscdat          ,
  segsex  like gsakseg.segsex          ,
  pestip  like gsakseg.pestip          ,
  viginc  like abamapol.viginc         ,
  vcluso  like abbmveic.vcluso         ,
  rspdat  like abbmquestionario.rspdat ,
  rspcod  like abbmquestionario.rspcod ,
  clscod  like abbmclaus.clscod
end record
define lr_retorno record
  idade  integer  ,
  perfil smallint ,
  dias   dec(10,2)
end record
#-----------------------------------------------------------
# Perfil 0 = Sem Perfil
# Perfil 1 = Tradicional (25 a 59 anos)
# Perfil 2 = Jovem (Menor de 25 anos)
# Perfil 3 = Senior ( Maior de 59 anos)
# Perfil 4 = Mulher (Sexo: F)
#-----------------------------------------------------------
initialize lr_retorno.* to null
   if lr_param.clscod = "035" or
      lr_param.clscod = "034" or
      lr_param.clscod = "033" or
      lr_param.clscod = "33R" then
      let lr_retorno.perfil = 0
      return lr_retorno.perfil
   end if
   let lr_retorno.dias   = 365.25
   #--------------#
   # Tradicional  #
   #--------------#
   let lr_retorno.perfil = 1

   let lr_retorno.idade = ((lr_param.viginc - lr_param.rspdat)/lr_retorno.dias)
   if lr_param.pestip = "F" then
      if lr_param.segsex = "M" then
      	 #--------------#
      	 # Jovem        #
      	 #--------------#
      	 if lr_retorno.idade < 25 then
      	    let lr_retorno.perfil = 2
      	 end if
      	 #--------------#
      	 # Senior       #
      	 #--------------#
      	 if lr_retorno.idade >= 60 then
      	     let lr_retorno.perfil = 3
      	 end if
      else
         if lr_retorno.idade >= 60 then
         	   #--------------#
         	   # Senior       #
         	   #--------------#
             let lr_retorno.perfil = 3
         else
         	   #--------------#
         	   # Mulher       #
         	   #--------------#
         	   let lr_retorno.perfil = 4
         end if
      end if
 	 end if
 	 if lr_param.pestip = "J" then
 	 	     if lr_param.vcluso = 1 then
 	 	     	 if lr_param.rspcod = 1 then
         	 #--------------#
         	 # Jovem        #
         	 #--------------#
         	 if lr_retorno.idade < 25 then
         	    let lr_retorno.perfil = 2
         	 end if
         	 #--------------#
         	 # Senior       #
         	 #--------------#
         	 if lr_retorno.idade >= 60 then
         	     let lr_retorno.perfil = 3
         	 end if
         else
         	  if lr_param.rspcod = 2 then
               #--------------#
               # Mulher       #
               #--------------#
               let lr_retorno.perfil = 4
               #--------------#
      	       # Senior       #
      	       #--------------#
      	       if lr_retorno.idade >= 60 then
      	           let lr_retorno.perfil = 3
      	       end if
            else
            	 let lr_retorno.perfil = 1
            end if
         end if
 	 	  else
 	 		   let lr_retorno.perfil = 1
 	 	  end if
 	 end if
   return lr_retorno.perfil
end function
#========================================================================
function bdata001_exibe_dados_parciais()
#========================================================================
   let mr_count1.des_clau = (mr_count1.apoli - mr_count1.claus2)
   display " "
   display "-----------------------------------------------------------"
   display " DADOS PARCIAIS - DATA ", mr_data.inicio
   display "-----------------------------------------------------------"
   display " "
   display " DADOS LIDOS APOLICE..............: ", mr_count1.apoli
   display " DADOS DESPREZADOS CLAUSULA.......: ", mr_count1.des_clau
   display " DADOS DESPREZADOS CPF/CNPJ.......: ", mr_count1.cpf
   display " DADOS LIDOS MOTOR CLAUSULA.......: ", mr_count1.lidos
   display " DADOS DESPREZADOS MOTOR CLAUSULA.: ", mr_count1.claus
   display " DADOS LIDOS MOTOR DE REGRAS......: ", mr_count1.motor
   display " DADOS DESPREZADOS COBERTURA......: ", mr_count1.cober
   display " DADOS DESPREZADOS CATEGORIA......: ", mr_count1.categ
   display " DADOS DESPREZADOS CIDADE.........: ", mr_count1.cidad
   display " DADOS GRAVADOS NO RELATORIO......: ", mr_count1.relat
#========================================================================
end function
#========================================================================
#========================================================================
function bdata001_exibe_dados_totais()
#========================================================================
   let mr_total.des_clau = (mr_total.apoli - mr_total.claus2)
   display " "
   display "-----------------------------------------------------------"
   display " DADOS TOTAIS "
   display "-----------------------------------------------------------"
   display " "
   display " TOTAIS LIDOS APOLICE..............: ", mr_total.apoli
   display " TOTAIS DESPREZADOS CLAUSULA.......: ", mr_total.des_clau
   display " TOTAIS DESPREZADOS CPF/CNPJ.......: ", mr_total.cpf
   display " TOTAIS LIDOS MOTOR CLAUSULA.......: ", mr_total.lidos
   display " TOTAIS DESPREZADOS MOTOR CLAUSULA.: ", mr_total.claus
   display " TOTAIS LIDOS MOTOR DE REGRAS......: ", mr_total.motor
   display " TOTAIS DESPREZADOS COBERTURA......: ", mr_total.cober
   display " TOTAIS DESPREZADOS CATEGORIA......: ", mr_total.categ
   display " TOTAIS DESPREZADOS CIDADE.........: ", mr_total.cidad
   display " TOTAIS GRAVADOS NO RELATORIO......: ", mr_total.relat
#========================================================================
end function
#========================================================================
#========================================================================
 function bdata001_recupera_quebra()
#========================================================================
define lr_retorno record
	cponom  like datkdominio.cponom,
	cpocod  like datkdominio.cpocod,
	cpodes  like datkdominio.cpodes
end record
initialize lr_retorno.* to null
let lr_retorno.cponom = "bdata001_quebra"
let lr_retorno.cpocod = 1
  open c_bdata001_020 using  lr_retorno.cponom ,
                             lr_retorno.cpocod
  whenever error continue
  fetch c_bdata001_020 into m_quebra
  whenever error stop
  if m_quebra =  ""   or
  	 m_quebra is null or
  	 m_quebra =  0    then
     return false
  end if
  return true
#========================================================================
end function
#========================================================================
#========================================================================
function bdata001_dispara_email()
#========================================================================
define lr_mail      record
       de           char(500)   # De
      ,para         char(5000)  # Para
      ,cc           char(500)   # cc
      ,cco          char(500)   # cco
      ,assunto      char(500)   # Assunto do e-mail
      ,mensagem     char(32766) # Nome do Anexo
      ,id_remetente char(20)
      ,tipo         char(4)     #
  end  record
define l_erro  smallint
define msg_erro char(500)
initialize lr_mail.* to null
    let lr_mail.de      = "ct24hs.email@portoseguro.com.br"
    let lr_mail.para    = bdata001_recupera_email()
    let lr_mail.cc      = ""
    let lr_mail.cco     = ""
    let lr_mail.assunto = "DADOS PROCESSADOS CARGA SIEBEL"
    let lr_mail.mensagem  = bdata001_monta_mensagem()
    let lr_mail.id_remetente = "CT24HS"
    let lr_mail.tipo = "html"
    #-----------------------------------------------
    # Dispara o E-mail
    #-----------------------------------------------
     call figrc009_mail_send1 (lr_mail.*)
     returning l_erro
              ,msg_erro
#========================================================================
end function
#========================================================================
#========================================================================
 function bdata001_recupera_email()
#========================================================================
define lr_retorno record
	cponom  like datkdominio.cponom,
	cpocod  like datkdominio.cpocod,
	cpodes  like datkdominio.cpodes,
	email   char(32766)            ,
	flag    smallint
end record
initialize lr_retorno.* to null
let lr_retorno.flag = true
let lr_retorno.cponom = "bdata001_email"
  open c_bdata001_027 using  lr_retorno.cponom
  foreach c_bdata001_027 into lr_retorno.cpodes
    if lr_retorno.flag then
      let lr_retorno.email = lr_retorno.cpodes clipped
      let lr_retorno.flag  = false
    else
      let lr_retorno.email = lr_retorno.email clipped, ";", lr_retorno.cpodes clipped
    end if
  end foreach
  return lr_retorno.email
#========================================================================
end function
#========================================================================
#========================================================================
function bdata001_monta_mensagem()
#========================================================================
define lr_retorno record
	mensagem  char(30000)
end record
initialize lr_retorno.* to null
          #-----------------------------------------------
          # Monta a Mensagem
          #-----------------------------------------------
          let lr_retorno.mensagem = " INICIO DO PROCESSAMENTO: "            , mr_param.ini, " - ", mr_param.hour_ini , "<br><br>",
                                    " FINAL DO PROCESSAMENTO: "             , mr_param.fim, " - ", mr_param.hour_fim , "<br><br>",
                                    " TOTAIS LIDOS APOLICE : "              , mr_total.apoli     , "<br>" ,
                                    " TOTAIS DESPREZADOS CLAUSULA : "       , mr_total.des_clau  , "<br>" ,
                                    " TOTAIS DESPREZADOS CPF/CNPJ : "       , mr_total.cpf       , "<br>" ,
                                    " TOTAIS LIDOS MOTOR CLAUSULA : "       , mr_total.lidos     , "<br>" ,
                                    " TOTAIS DESPREZADOS MOTOR CLAUSULA : " , mr_total.claus     , "<br>" ,
                                    " TOTAIS LIDOS MOTOR DE REGRAS : "      , mr_total.motor     , "<br>" ,
                                    " TOTAIS DESPREZADOS COBERTURA : "      , mr_total.cober     , "<br>" ,
                                    " TOTAIS DESPREZADOS CATEGORIA : "      , mr_total.categ     , "<br>" ,
                                    " TOTAIS DESPREZADOS CIDADE : "         , mr_total.cidad     , "<br>" ,
                                    " TOTAIS GRAVADOS NO RELATORIO : "      , mr_total.relat     , "<br>"
          return lr_retorno.mensagem
#========================================================================
end function
#========================================================================